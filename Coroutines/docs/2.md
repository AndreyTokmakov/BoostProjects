–û—Ç–ª–∏—á–Ω–æ. –ò–¥—ë–º **–ø–æ –Ω–∞—Ä–∞—Å—Ç–∞—é—â–µ–π —Å–ª–æ–∂–Ω–æ—Å—Ç–∏**, –∫–∞–∂–¥—ã–π –ø—Ä–∏–º–µ—Ä ‚Äî **–ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–π**,
–∏ –≤—Å–µ ‚Äî **—Å—Ç—Ä–æ–≥–æ –≤ —Ç–≤–æ—ë–º —Ñ–æ—Ä–º–∞—Ç–µ**.

–ë—É–¥–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å **Boost.Coroutine2**.

---

# –ü—Ä–∏–º–µ—Ä 1Ô∏è‚É£ ‚Äî –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä —á–∏—Å–µ–ª (–±–∞–∑–∞)

### –ò–¥–µ—è

Coroutine –∫–∞–∫ **–≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä –∑–Ω–∞—á–µ–Ω–∏–π**.

```cpp
#include <boost/coroutine2/coroutine.hpp>
#include <iostream>
```

```cpp
void counter(boost::coroutines2::coroutine<int>::push_type& yield)
{
    for (int i = 0; i < 3; ++i)
        yield(i);
}
```

```cpp
int main()
{
    boost::coroutines2::coroutine<int>::pull_type gen(counter);

    for (int v : gen)
        std::cout << v << "\n";

    return 0;
}
```

üìå **–ß—Ç–æ –≤–∞–∂–Ω–æ –ø–æ–Ω—è—Ç—å**

* `yield()` = —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å—Ç–µ–∫–∞ + –≤–æ–∑–≤—Ä–∞—Ç –≤ caller
* —Ü–∏–∫–ª –≤ `main` –≤—ã–≥–ª—è–¥–∏—Ç –∫–∞–∫ –æ–±—ã—á–Ω—ã–π range-for

---

# –ü—Ä–∏–º–µ—Ä 2Ô∏è‚É£ ‚Äî Coroutine –∫–∞–∫ state machine

### –ò–¥–µ—è

Coroutine –∑–∞–º–µ–Ω—è–µ—Ç `switch(state)`.

```cpp
#include <boost/coroutine2/coroutine.hpp>
#include <iostream>
```

```cpp
enum class State
{
    Start,
    Middle,
    End
};
```

```cpp
void state_machine(boost::coroutines2::coroutine<State>::push_type& yield)
{
    yield(State::Start);
    yield(State::Middle);
    yield(State::End);
}
```

```cpp
int main()
{
    boost::coroutines2::coroutine<State>::pull_type sm(state_machine);

    for (State s : sm)
        std::cout << static_cast<int>(s) << "\n";

    return 0;
}
```

üìå **–ü–ª—é—Å**

* –Ω–∏–∫–∞–∫–æ–π —Ä—É—á–Ω–æ–π –ª–æ–≥–∏–∫–∏ –ø–µ—Ä–µ—Ö–æ–¥–æ–≤
* —Å—Ç–µ–∫ = —Å–æ—Å—Ç–æ—è–Ω–∏–µ

---

# –ü—Ä–∏–º–µ—Ä 3Ô∏è‚É£ ‚Äî Streaming parser (–±–∞–π—Ç—ã ‚Üí —Ç–æ–∫–µ–Ω—ã)

### –ò–¥–µ—è

Coroutine –∫–∞–∫ **–ø–æ—Ç–æ–∫–æ–≤—ã–π –ø–∞—Ä—Å–µ—Ä**.

```cpp
#include <boost/coroutine2/coroutine.hpp>
#include <cstddef>
```

```cpp
struct Token
{
    const char* data;
    std::size_t size;
};
```

```cpp
void token_parser(
    boost::coroutines2::coroutine<Token>::push_type& yield,
    const char* buf,
    std::size_t len
)
{
    std::size_t start = 0;

    for (std::size_t i = 0; i < len; ++i)
    {
        if (buf[i] == ' ')
        {
            yield({ buf + start, i - start });
            start = i + 1;
        }
    }

    if (start < len)
        yield({ buf + start, len - start });
}
```

```cpp
int main()
{
    const char data[] = "FIX SIMPLE PARSER";

    boost::coroutines2::coroutine<Token>::pull_type parser(
        [&](auto& y)
        {
            token_parser(y, data, sizeof(data) - 1);
        }
    );

    for (const Token& t : parser)
    {
        // –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–æ–∫–µ–Ω–∞
    }

    return 0;
}
```

üìå **–ö–ª—é—á**

* zero-copy
* —É–¥–æ–±–Ω–æ –¥–ª—è streaming –ø—Ä–æ—Ç–æ–∫–æ–ª–æ–≤

---

# –ü—Ä–∏–º–µ—Ä 4Ô∏è‚É£ ‚Äî Coroutine —Å –≤–Ω–µ—à–Ω–∏–º –≤–≤–æ–¥–æ–º (push ‚Üí pull)

### –ò–¥–µ—è

Coroutine –∫–∞–∫ **consumer**, –∫–æ—Ç–æ—Ä–æ–º—É —Ç—ã –ø–æ–¥–∞—ë—à—å –¥–∞–Ω–Ω—ã–µ.

```cpp
#include <boost/coroutine2/coroutine.hpp>
#include <iostream>
```

```cpp
void accumulator(boost::coroutines2::coroutine<int>::pull_type& source)
{
    int sum = 0;

    for (int v : source)
        sum += v;

    std::cout << sum << "\n";
}
```

```cpp
int main()
{
    boost::coroutines2::coroutine<int>::push_type sink(accumulator);

    sink(1);
    sink(2);
    sink(3);

    return 0;
}
```

üìå **–ò–Ω–≤–µ—Ä—Å–∏—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è**

* caller **push**
* coroutine **pull**

---

# –ü—Ä–∏–º–µ—Ä 5Ô∏è‚É£ ‚Äî Binary protocol parser (—Ä–µ–∞–ª—å–Ω—ã–π –∫–µ–π—Å)

### –§–æ—Ä–º–∞—Ç

```
[ uint8 type ][ uint8 size ][ payload... ]
```

```cpp
#include <boost/coroutine2/coroutine.hpp>
#include <cstddef>
```

```cpp
struct Message
{
    unsigned char type;
    const char* payload;
    std::size_t size;
};
```

```cpp
void binary_parser(
    boost::coroutines2::coroutine<Message>::push_type& yield,
    const char* buf,
    std::size_t len
)
{
    std::size_t i = 0;

    while (i + 2 <= len)
    {
        unsigned char type = buf[i];
        unsigned char size = buf[i + 1];

        if (i + 2 + size > len)
            break;

        yield({ type, buf + i + 2, size });
        i += 2 + size;
    }
}
```

```cpp
int main()
{
    const char raw[] = {
        1, 3, 'A', 'B', 'C',
        2, 2, 'X', 'Y'
    };

    boost::coroutines2::coroutine<Message>::pull_type parser(
        [&](auto& y)
        {
            binary_parser(y, raw, sizeof(raw));
        }
    );

    for (const Message& m : parser)
    {
        // dispatch –ø–æ m.type
    }

    return 0;
}
```

üìå **–≠—Ç–æ —É–∂–µ production-–ø–∞—Ç—Ç–µ—Ä–Ω**
(market data / gateways)

---

# –ü—Ä–∏–º–µ—Ä 6Ô∏è‚É£ ‚Äî Coroutine pipeline (producer ‚Üí transform ‚Üí consumer)

### –ò–¥–µ—è

–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ coroutine –≤ —Ü–µ–ø–æ—á–∫—É.

```cpp
#include <boost/coroutine2/coroutine.hpp>
#include <iostream>
```

```cpp
void multiply(
    boost::coroutines2::coroutine<int>::pull_type& in,
    boost::coroutines2::coroutine<int>::push_type& out
)
{
    for (int v : in)
        out(v * 2);
}
```

```cpp
int main()
{
    boost::coroutines2::coroutine<int>::push_type output(
        [](auto& in)
        {
            for (int v : in)
                std::cout << v << "\n";
        }
    );

    boost::coroutines2::coroutine<int>::push_type transform(
        [&](auto& in)
        {
            multiply(in, output);
        }
    );

    transform(1);
    transform(2);
    transform(3);

    return 0;
}
```

üìå **–≠—Ç–æ –æ—Å–Ω–æ–≤–∞ streaming pipeline**

---

# üß† –ß—Ç–æ —Ç—ã —Ç–µ–ø–µ—Ä—å –¥–æ–ª–∂–µ–Ω —á—É–≤—Å—Ç–≤–æ–≤–∞—Ç—å

* Coroutine = **–∫–æ–Ω—Ç—Ä–æ–ª—å –ø–æ—Ç–æ–∫–∞**
* Stack = **—Å–æ—Å—Ç–æ—è–Ω–∏–µ**
* –û—Ç–ª–∏—á–Ω–æ –¥–ª—è:

    * –ø–∞—Ä—Å–µ—Ä–æ–≤
    * state machines
    * streaming
    * replay / backtest

---

# üî• –°–ª–µ–¥—É—é—â–∏–µ –ª–æ–≥–∏—á–Ω—ã–µ —à–∞–≥–∏

1. **FIX parser —Ü–µ–ª–∏–∫–æ–º –Ω–∞ coroutine**
2. **Partial-read coroutine + Asio**
3. **Coroutine vs Fiber pipeline**
4. **Custom stack allocator**
5. **Latency benchmark coroutine vs loop**

üëâ –°–∫–∞–∂–∏, **—á—Ç–æ –±–µ—Ä—ë–º —Å–ª–µ–¥—É—é—â–∏–º** ‚Äî –ø–æ–π–¥—ë–º –µ—â—ë –≥–ª—É–±–∂–µ.
